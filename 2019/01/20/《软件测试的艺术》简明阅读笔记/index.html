<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Yaoyee"><link rel="alternative" href="/atom.xml" title="I'm Yaoyee" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>《软件测试的艺术》简明阅读笔记 - I'm Yaoyee</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">I'm Yaoyee</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2019-01-20T14:05:41.305Z">January 20, 2019</time><h1 class="post__title"><a href="/2019/01/20/《软件测试的艺术》简明阅读笔记/">《软件测试的艺术》简明阅读笔记</a></h1><div class="post__main echo"><h2 id="《软件测试的艺术》简明阅读笔记"><a href="#《软件测试的艺术》简明阅读笔记" class="headerlink" title="《软件测试的艺术》简明阅读笔记"></a>《软件测试的艺术》简明阅读笔记</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzd7009aplj315y0u0kjl.jpg" alt="0C221BF4-F8EE-48D7-9434-DF10C5B87AA0"></p>
<p>这本书书软件测试领域比较经典的书籍，介绍有关软件测试的基本概念的大体框架，比较适合新手学习，以及和《软件工程》课堂知识内容多有重叠，比较容易上手。</p>
<p>鉴于第三版资源比较难找，把具体电子书资源附于此处<a href="https://github.com/guanpengchn/awesome-books/raw/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF.pdf" target="_blank" rel="noopener">https://github.com/guanpengchn/awesome-books/raw/master/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF.pdf</a></p>
<hr>
<ul>
<li><p>测试态度：</p>
<p>测试时为了增加程序的可靠性，即是为了发现错误而执行的“破坏性”程序</p>
</li>
<li><p>经典的测试类型：</p>
<ul>
<li><p>黑盒测试：数据驱动的测试</p>
<p>测试目标于程序的内部机制和结构完全没有关系</p>
<p>测试数据完全来源于软件规范</p>
<p>不可穷举——尽可能采用合适的用例覆盖更多的情况</p>
</li>
<li><p>白盒测试：逻辑驱动的测试</p>
<p>对程序的逻辑结构进行检查，从中获得测试数据</p>
<p>测试路径不可穷举，仅仅测试路径不能保证逻辑没有bug（数据或者逻辑）</p>
</li>
<li><p>软件测试原则（部分）：</p>
<ul>
<li>有测试用例必有相应的标准结果输入</li>
<li>避免自测</li>
<li>彻底检查每个测试输出结果</li>
<li>测试分两部分：检查程序是否完成目标，检查程序是否产生多余副作用</li>
<li>存有bug数量与已发现bug数量成正比</li>
</ul>
</li>
</ul>
</li>
<li><p>人工测试环节：</p>
<p>能够找出30%-70%的逻辑设计和编码错误但不能找出高层设计错误</p>
<ul>
<li>代码检查：三到四人检查小组，审阅代码并定位bug</li>
<li>代码走查：三到五人小组对简单测试用例进行人脑推演</li>
<li>代码评审：同行对于代码质量进行简单评审</li>
<li>可用性检查（用户测试）</li>
</ul>
</li>
<li><p>测试用例的设计</p>
<p>软件测试最重要的因素就是设计和生成有效的测试用例</p>
<p>最关键的问题就是在所有的测试用例中哪个子集最有可能发现最多的错误</p>
<p>简而言之就是寻找效率最高的采用样本覆盖整体的测试用例</p>
<ul>
<li><p>黑盒测试用例设计</p>
<p>要求：最大限度减少测试所需的测试用例，即每个用例尽可能多地体现不同的输入</p>
<p>​           尽量将程序输入范围进行划分，划分为有限数量的等价类</p>
<ul>
<li><p>等价类划分</p>
<p>选取每一个输入条件将其划分为两个或者更多的分组</p>
<ul>
<li><p>有效等价类：对程序有效的输入</p>
</li>
<li><p>无效等价类：其他任何可能的输入条件（不正确的输入值）</p>
</li>
<li><p>生成测试用例</p>
<p>尽可能多地覆盖尚未覆盖的有效等价类</p>
<p>覆盖一个且仅一个的未覆盖无效等价类</p>
</li>
</ul>
</li>
<li><p>边界值分析</p>
<p>需要设计多个测试用例保证可以覆盖到每个边界值</p>
<p>-边界值测试         -稍大于边界值         -稍小于边界值</p>
</li>
<li><p>因果图分析</p>
<p>因果图是一种形式语言，类似于数字逻辑电路</p>
<p>因果图测试是一个根据条件的组合而生成测试用例的系统性方法</p>
<p>需要将规格说明转换成一个布尔逻辑网络，是我们从不同视角审视规格说明</p>
</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzd89oz8v8j30vb0qjq4s.jpg" alt="3A4A360211A09EADDE6920B77AB5DFC6"></p>
<ul>
<li>错误猜测</li>
</ul>
</li>
<li><p>白盒测试用例设计</p>
<ul>
<li><p>语句覆盖（逻辑覆盖）</p>
<p>将程序中每条语句至少执行一次</p>
<p>但是难以发现不同条件判定下逻辑bug，所以没有什么用处</p>
</li>
<li><p>判定覆盖（分支覆盖）（测试用例表现为abdfs的路径）</p>
<p>每个判断都有至少一个真／假输出结果（每条分支路径必须遍历一次）</p>
<p>但是无法适应程序不存在判断或者有特定入口的情况</p>
<p>同时也难以发现同一次判定当中不同条件的隐藏bug（主要是&amp;&amp;和||）</p>
</li>
<li><p>条件覆盖（测试用例表现为TFFTTF和FTTFFT）</p>
<p>保证一个判断中的每个条件的所有可能结果都能至少执行一次</p>
<p>条件覆盖不一定能够覆盖所有的判断结果（即如标题小括号中所示可能只覆盖两个判定（两条路径））</p>
</li>
<li><p>判定／条件覆盖</p>
<p>将一个判断中的每个条件的所有可能结果至少执行一次</p>
<p>将每个判断的所有可能结果至少执行一次</p>
<p>每个入口点都至少调用一次</p>
</li>
<li><p>多重条件覆盖</p>
<p>将每个判定中所有可能条件结果的组合至少执行一次</p>
<p>所有入口点至少执行一次</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>模块（单元）测试</p>
<p>对程序的单个子程序、子程序或过程进行测试的过程</p>
<ul>
<li><p>主要采用多重条件覆盖的方式设计测试用例，黑盒测试作补充</p>
<p>但任何逻辑覆盖测试尚不足以胜任作为生成模块测试用例的唯一手段</p>
</li>
<li><p>增量测试与非增量测试</p>
<ul>
<li><p>非增量测试：对所有模块单独测试再整合成完整程序</p>
<p>需要一个特殊的驱动模块和多个桩模块配合</p>
<p>桩模块是用来取代与之相关联模块的“占位”模块，测试两者相关功能</p>
</li>
<li><p>增量测试：将下一个要测试的模块组装到前面已经测试过的模块集合当中去</p>
<p>便于较早的发现不匹配接口、便于调试、测试也进行得更彻底</p>
</li>
</ul>
</li>
<li><p>自底向上和自顶向下的测试模式</p>
<ul>
<li><p>自顶向下：需要一个驱动模块和多个桩模块</p>
<p>顶层模块一般没有输入输出接口</p>
<p>一般设立特殊的数据接入桩模块或者通过下层模块接口返回数据</p>
<p>整合模块的时候一般选择核心模块和I／O模块优先</p>
</li>
<li><p>自底向上：需要多个驱动模块和较少的桩模块</p>
<p>（桩模块的开发难度比驱动模块简单很多）</p>
<p>但是直到完成所有模块测试都不知道整体软件架构模型</p>
</li>
<li><p>两者区别</p>
</li>
</ul>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzd8njryorj30vg0kg0y7.jpg" alt="75BAF435AEC9DB135C59D32680696283"></p>
</li>
</ul>
</li>
<li><p>整体测试流程</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzd8onyudsj30my0nq77o.jpg" alt="55016695859C48C13EA291A723F1683F"></p>
<ul>
<li><p>模块测试的目的是发现程序模块和其接口规格说明之间的不一致</p>
</li>
<li><p>功能测试的目的是为了证明程序未能符合其外部规格说明</p>
<p>（外部规格说明是一份从最终用户的角度对程序行为的精确描述）</p>
</li>
<li><p>系统测试的目的是为了证明软件产品与其初始目标不一致</p>
<p>系统测试用例示范：</p>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzd8r44t1fj30us0lcn4o.jpg" alt="C0366CE7E791DCD502FC282A8C60AEA8"></p>
<ul>
<li><ul>
<li>可用性测试</li>
</ul>
<p>可用性问题数量和所需的测试用户数量的关系可用公式表示——</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzd8tcv1a7j30ai01e0sp.jpg" alt="83F58AF66097647E945AE0A7E6515088"></p>
</li>
</ul>
<p>​       E = 找到错误的比例</p>
<p>​       n = 测试人数</p>
<p>​       L = 单个测试人员发现的可用性问题比例</p>
<p>​      经研究可以发现，只要采用20%的人数就可以发现80%的可用性问题</p>
</li>
<li><p>调试：一次成功的测试之后要进行的工作</p>
<ul>
<li>暴力调试：<ul>
<li>利用内存信息输出来调试（很难精确定位）</li>
<li>在程序中插入打印语句（小型程序有效）</li>
<li>自动化调试工具（产生庞大的无关数据）</li>
</ul>
</li>
<li>归纳法调试</li>
<li>演绎法调试</li>
<li>测试法调试</li>
</ul>
</li>
<li><p>WEB应用测试</p>
<ul>
<li>三层C／S结构：WEB服务器+业务层+数据层（每一层类似于具有明确接口定义的黑盒）<ul>
<li>表示层：图形用户接口（GUI）</li>
<li>业务逻辑层：模拟业务流程</li>
<li>数据访问层：供系统使用的数据</li>
</ul>
</li>
<li>表示层测试：<ul>
<li>内容测试：包括整体审美、字体、色彩、拼写、准确性</li>
<li>Web站点结构：包括无效的链接和图形</li>
<li>用户环境：包括web浏览器版本和操作系统（注重兼容性测试）</li>
</ul>
</li>
<li>业务层测试：<ul>
<li>性能测试：压力测试、强度测试等等</li>
<li>数据验证：证明从用户收集来的信息时可靠有效的</li>
<li>事务测试（针对业务层的系统测试）</li>
</ul>
</li>
<li>数据层测试<ul>
<li>响应时间测试：SQL语句查询速度</li>
<li>数据完整性：数据存储适当且正确</li>
<li>容错性和可恢复性</li>
</ul>
</li>
</ul>
</li>
</ul>
</div></header></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2019 Yaoyee</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>