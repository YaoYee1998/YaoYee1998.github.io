<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Yaoyee"><link rel="alternative" href="/atom.xml" title="I'm Yaoyee" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title> - I'm Yaoyee</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">I'm Yaoyee</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2019-05-15T14:36:56.773Z">May 15, 2019</time><h1 class="post__title"><a href="/2019/05/15/nginx原理/"></a></h1><div class="post__main echo"><hr>
<h2 id="title：Nginx基本概念与操作"><a href="#title：Nginx基本概念与操作" class="headerlink" title="title：Nginx基本概念与操作"></a>title：Nginx基本概念与操作</h2><p>####静态服务器</p>
<p>Nginx是一个HTTP服务器，可以将服务器上的静态文件（如HTML、图片）通过HTTP协议展现给客户端。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment"># 端口号</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/html; <span class="comment"># 静态文件路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="反向代理服务器"><a href="#反向代理服务器" class="headerlink" title="反向代理服务器"></a>反向代理服务器</h4><p>以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p>
<p>客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理服务器将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。如此可以保证内部网络对于外部网络是不可见的，没有保存任何网页的真实数据，所有的静态网页都在内部服务器上，增强了内网的安全性。</p>
<p>理解：正向代理可以向服务器隐匿客户端的存在，反向代理则可以假装作为客户端的服务器</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g30u768jumj314m0hc13v.jpg" alt="image-20190514143820971"></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.0.112:8080; <span class="comment"># 应用服务器HTTP地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>######工作流程（带缓存）：</p>
<p>反向代理可以被当作web服务器和客户端之间的一个高速缓存，接受客户端的请求，并把相应的请求内容缓存在本地以防止短时间内再次请求，提高了相应的速度</p>
<ol>
<li>用户通过域名发出访问Web服务器的请求，该域名被DNS服务器解析为反向代理服务器的IP地址</li>
<li>反向代理服务器接受用户的请求；</li>
<li>反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户；</li>
<li>如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户并缓存。</li>
</ol>
<h4 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h4><p>如果网站访问量较小，可以将多个网站部署在同一台服务器上来节约成。本</p>
<p>例如将<a href="https://link.jianshu.com?t=http://www.aaa.com" target="_blank" rel="noopener">www.aaa.com</a>和<a href="https://link.jianshu.com?t=http://www.bbb.com" target="_blank" rel="noopener">www.bbb.com</a>两个网站部署在同一台服务器上，两个域名解析到同一个IP地址，但是用户通过两个域名却可以打开两个完全不同的网站，互相不影响，就像访问两个服务器一样，所以叫两个虚拟主机。</p>
<p>虚拟主机可以节约有限的IP地址，例如，一个企业内所有的网站共享一个在internet中注册的IP地址，这些服务器分配私有地址，采用虚拟主机的方式对外提供服务。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">444</span>; <span class="comment"># 过滤其他域名的请求，返回444状态码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.aaa.com; <span class="comment"># www.aaa.com域名</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8080; <span class="comment"># 对应端口号8080</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.bbb.com; <span class="comment"># www.bbb.com域名</span></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8081; <span class="comment"># 对应端口号8081</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>当网络的访问量非常大的时候，将相同的应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。同时带来的好处是，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> myapp &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.111:8080</span>; <span class="comment"># 应用服务器1</span></span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.0.112:8080</span>; <span class="comment"># 应用服务器2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://myweb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="nginx的模块和工作原理"><a href="#nginx的模块和工作原理" class="headerlink" title="nginx的模块和工作原理"></a>nginx的模块和工作原理</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g32655sjhgj30jg0c3abb.jpg" alt="img"></p>
<p>内核工作原理：通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。</p>
<p>######结构分类：</p>
<p><strong>核心模块</strong>：HTTP模块、EVENT模块和MAIL模块</p>
<p><strong>基础模块</strong>：HTTP Access、HTTP FastCGI、HTTP Proxy、HTTP Rewrite</p>
<p><strong>第三方模块</strong>：HTTP Upstream Request Hash、Notice、HTTP Access Key</p>
<h6 id="功能分类"><a href="#功能分类" class="headerlink" title="功能分类"></a>功能分类</h6><p><strong>Core(核心模块)：</strong>构建nginx基础服务、管理其他模块。</p>
<p><strong>Handlers（处理器模块）：</strong>此类模块直接处理请求，并进行输出内容和修改headers信息等操作。</p>
<p><strong>Filters （过滤器模块）：</strong>此类模块主要对其他处理器模块输出的内容进行修改操作，最后由Nginx输出。过滤模块可以对回复的头和内容进行处理。它的处理时间在获取回复内容之后，向用户发送响应之前。它的处理过程分为两个阶段，过滤HTTP回复的头部和主体，在这两个阶段可以分别对头部和主体进行修改。过滤模块通常以buffer（缓冲区）为单位进行操作，这些buffer一般都是一页（4K）大小，也可以在nginx.conf文件中进行配置。</p>
<p><strong>Proxies （代理类模块）：</strong>此类模块是Nginx的HTTP Upstream之类的模块，这些模块主要与后端一些服务比如FastCGI等进行交互，实现服务代理和负载均衡等功能。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g324e66arij30je0c775d.jpg" alt="img"></p>
<h4 id="进程模式"><a href="#进程模式" class="headerlink" title="进程模式"></a>进程模式</h4><p>nginx进程包含一个master和多个worker进程，master主要用来读取并验证配置文件nginx.conf并管理worker进程，基本的网络状态都交work来处理（多个work之间对等且相互独立）</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g3250futhpj30fu0a6dg4.jpg" alt="img"></p>
<h6 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h6><p>配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效。master会重新生成新的worker进程，并会以新的配置和新的work进行处理请求，而老的worker在收到来自master的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。</p>
<h6 id="惊群现象"><a href="#惊群现象" class="headerlink" title="惊群现象"></a>惊群现象</h6><p>首先，每个worker进程都是从master进程fork过来，在master进程里面，先建立好需要listen的socket（listenfd）之后，然后再fork出多个worker进程。所有worker都会监听相同ip端口的套接字socket fd，意味着当有一个请求进来的时候，所有的worker都会感知到。这样就会产生所谓的“惊群现象”。为了保证只会有一个进程成功注册到listenfd的读事件，nginx中实现了一个“accept_mutex”类似互斥锁，只有获取到这个锁的进程，才可以去注册读事件，在读事件里调用accept接受该连接。当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后断开连接</p>
<h4 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h4><p>这里的并发请求，是指未处理完的请求，work的线程本身只有一个，同时只能处理的一个请求，Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件，事件准备完毕即放入epoll队列中，这个过程是异步的，worker只需要从epoll队列循环处理即可。即”并发”的事件其实只是在请求间进行不断地切换而已，这里的切换没有任何代价，相当于循环处理多个准备好的事件。</p>
<p>与多线程相比，这种事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常的轻量级。并发数再多也不会导致无谓的资源浪费（上下文切换）。</p>
<p>一般来说，推荐设置worker的个数为cpu的核数，更多的worker数，只会导致进程来竞争cpu资源了，从而带来不必要的上下文切换。而且，nginx为了更好的利用多核特性，提供了cpu亲缘性的绑定选项，可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。</p>
<p>####网络链接connection</p>
<p>在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。nginx中的http请求的处理就是建立在connection之上的，所以nginx不仅可以作为一个web服务器，也可以作为邮件服务器。</p>
<p>首先，nginx在启动时，会解析配置文件，得到需要监听的端口与ip地址，然后在nginx的master进程里面，先初始化好这个监控的socket(创建socket，设置addrreuse等选项，绑定到指定的ip地址端口，再listen)，然后再fork出多个子进程出来，然后子进程会竞争accept新的连接。此时，客户端就可以向nginx发起连接了。当客户端与服务端通过三次握手建立好一个连接后，nginx的某一个子进程会accept成功，得到这个建立好的连接的socket，然后创建nginx对连接的封装，即ngx_connection_t结构体。接着，设置读写事件处理函数并添加读写事件来与客户端进行数据的交换。最后，nginx或客户端来主动关掉连接，并释放ngx_connection_t。</p>
<p>在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。在nginx中，通过设置worker_connectons来设置每个进程支持的最大连接数。如果该值大于nofile，那么实际的最大连接数是nofile，nginx会有警告。nginx的每个worker进程都有一个独立的连接池，连接池的大小是worker_connections，其中保存有ngx_connection_t的链表用来管理链接数，如果是作为反向代理，最大并发数量应该是worker_connections * worker_processes/2。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>启动Nginx</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx</span><br></pre></td></tr></table></figure>
<p>停止Nginx    (-s代表采用向 Nginx 发送信号的方式。)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx -s stop</span><br><span class="line">./sbin/nginx -s quit</span><br></pre></td></tr></table></figure>
<p>Nginx重新载入配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx -s reload</span><br></pre></td></tr></table></figure>
<p>查看版本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx -v （简略信息）</span><br><span class="line">./sbin/nginx -V （详细信息）</span><br></pre></td></tr></table></figure>
<p>查看配置是否正确</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx -t</span><br></pre></td></tr></table></figure>
<p>参考链接：</p>
<p><a href="https://www.jianshu.com/p/6215e5d24553" target="_blank" rel="noopener">https://www.jianshu.com/p/6215e5d24553</a></p>
<p><a href="https://www.jianshu.com/p/630e2e1ca57f?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/630e2e1ca57f?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p>
</div></header></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2019 Yaoyee</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>